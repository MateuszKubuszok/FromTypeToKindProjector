<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>From Type to Kind Projector</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="./css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="./css/theme/black.css" id="theme"><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><link href="./lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "./css/print/pdf.css" : "./css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="./lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>From Type to Kind Projector</h1><div class="preamble"><div class="paragraph"><p>Mateusz Kubuszok</p></div>
<aside class="notes"><div class="paragraph"><p>Mention that whole presentaiton consitsts of 2 parts.</p></div>
<div class="paragraph"><p>part 1 - for newbies</p></div>
<div class="paragraph"><p>part 2 - for people who already know something</p></div>
<div class="paragraph"><p>Skipped:</p></div>
<div class="ulist"><ul><li><p>F-bound types</p></li><li><p>self-types</p></li><li><p>tagged and value types</p></li><li><p>phantom and literal types</p></li></ul></div></aside></div></section>
<section id="code_introduction_to_types_code"><h2><code>Introduction to Types</code></h2></section>
<section><section id="what_is_a_type"><h2>What is a Type?</h2><aside class="notes"><div class="paragraph"><p>Ask audience before moving on.</p></div></aside></section><section id="intuitively"><h2>Intuitively</h2><div class="paragraph"><p><span class="fragment">A collection of values</span></p></div>
<div class="paragraph"><p><span class="fragment">(TODO add image of some int and string sets)</span></p></div>
<aside class="notes"><div class="paragraph"><p>Type is kinda like set except sets are in different thery.</p></div></aside></section><section id="example"><h2>Example</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">// type annotation

val i: Int    = 0   // value i = 0 is of type Int
val s: String = "a" // value s = "a" is of type String

def double(x: Int): Int = x * 2

// type ascription


0 : Int // compiles because it is true
"": Int // fails to compile</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>TT: <code>a: A</code> is judgement - it means that a is of type A</p></div>
<div class="paragraph"><p>Type annotation - stating type explicitly.</p></div>
<div class="paragraph"><p>Type ascription - demanding of compiler to make sure value
can be judged as some type.</p></div></aside></section><section id="subtype_supertype"><h2>Subtype &amp; Supertype</h2><div class="paragraph"><p>(TODO image with member and admin as subtypes of user)</p></div></section><section id="subtype_supertype_2"><h2>Subtype &amp; Supertype</h2><div class="stemblock"><div class="content">\[(Member &lt;: User) \\
\Updownarrow \\
\forall_a (a : Member \implies a : User)\]</div></div></section><section id="subtype_supertype_3"><h2>Subtype &amp; Supertype</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait User
class Member extends User
class Admin extends User</code></pre></div></div></section><section id="subtype_supertype_4"><h2>Subtype &amp; Supertype</h2><div class="paragraph"><p>(image with admin as a subtype of user)</p></div></section><section id="subtype_supertype_5"><h2>Subtype &amp; Supertype</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class User
class Admin extends User</code></pre></div></div></section></section>
<section><section id="least_upper_bound_and_type_inference"><h2>Least Upper Bound and Type Inference</h2></section><section id="example_2"><h2>Example</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val i: Int
val x = if (i &gt;= 0) Some(i) // Some[Int]
        else None           // None
// what is the type of x?</code></pre></div></div></section><section id="example_type_hierarchy"><h2>Example Type Hierarchy</h2><div class="imageblock" style=""><img src="img/hierarchy.svg" alt="hierarchy"></div>
<aside class="notes"><div class="paragraph"><p>Explain Any, AnyVal, AnyRef, Nothing and Null.</p></div></aside></section><section id="types_of_code_some_i_code"><h2>Types of <code>Some(i)</code></h2><div class="imageblock" style=""><img src="img/hierarchy-some.svg" alt="hierarchy some"></div></section><section id="types_of_code_none_code"><h2>Types of <code>None</code></h2><div class="imageblock" style=""><img src="img/hierarchy-none.svg" alt="hierarchy none"></div></section><section id="common_part"><h2>Common part</h2><div class="imageblock" style=""><img src="img/hierarchy-option.svg" alt="hierarchy option"></div></section><section id="least_upper_bound"><h2>Least Upper Bound</h2><div class="quoteblock"><blockquote><div class="paragraph"><p><strong>Least Upper Bound</strong> of a - the least type T for which judgement
a : T is provable to be true</p></div></blockquote></div>
<div class="quoteblock"><blockquote><div class="paragraph"><p><strong>Type Inference</strong> - finding the LUB of a value</p></div></blockquote></div></section><section id="example_3"><h2>Example</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val i: Int
val x = if (i &gt;= 0) Some(i) // Some[Int]
        else None           // None
// x: Option[Int]</code></pre></div></div></section></section>
<section><section id="adt"><h2>ADT</h2><div class="paragraph"><p><span class="fragment">ADT is either a <strong>product</strong> or <strong>coproduct</strong> type. :)</span></p></div><div class="paragraph"><p><span class="fragment">But what are product and coproduct types?</span></p></div><aside class="notes"><div class="paragraph"><p>Explain that now we will talk about:
tuples &#8594; cartesian products &#8594; sum types</p></div></aside></section><section id="tuple"><h2>Tuple</h2><div class="quoteblock"><blockquote><div class="paragraph"><p>A <strong>tuple</strong> or an <strong>ordered pair</strong>, is a collection of two elements,
where we select one of them as the first.</p></div></blockquote></div>
<div class="paragraph"><p>In set theory we can define them as:</p></div>
<div class="stemblock"><div class="content">\[(a, b) = \{\{a\}, \{a,b\}\}\]</div></div></section><section id="cartesian_product_of_2"><h2>Cartesian Product of 2</h2><div class="stemblock"><div class="content">\[A \times B = \{ (a, b): a \in A \land b \in B \}\]</div></div></section><section id="n_tuple"><h2>n-tuple</h2><div class="stemblock"><div class="content">\[(a, b, c) = (a, (b, c)) \\
(a, b, c, d) = (a, (b, (c, d))) \\
...\]</div></div>
<aside class="notes"><div class="paragraph"><p>In programming languages we make n-tuples right associative.</p></div>
<div class="paragraph"><p>In mathematics they are left associative.</p></div></aside></section><section id="cartesian_product_of_n"><h2>Cartesian Product of n</h2><div class="paragraph"><p>Generalization of Cartesian product:</p></div>
<div class="stemblock"><div class="content">\[A \times B \times C = \{ (a, b, c): a \in A \land b \in B \land c \in C \} \\
A \times B \times C = A \times (B \times C) \\
A \times B \times C \times D = A \times (B \times (C \times D)) \\
...\]</div></div></section><section id="product_types"><h2>Product types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">type X = (String, Int, Double)
type Y = Tuple3[String, Int, Double]
case class Z(s: String, i: Int, d: Double)
class Z2(val s: String, val i: Int, val d: Double)

import shapeless._
String :: Int :: Double :: HNil</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Mention shapeless <code>HList</code> and the concept of cons.</p></div></aside></section><section id="disjoint_union"><h2>Disjoint union</h2><div class="stemblock"><div class="content">\[X = Y|Z \iff (x : X \implies x : Y \veebar x : Z)\]</div></div>
<aside class="notes"><div class="paragraph"><p>Mention concept of tags. And that this is XOR!</p></div></aside></section><section id="disjoint_union_2"><h2>Disjoint union</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">sealed trait Credentials

final case class LoginPassword(
    login: String,
    password: String
) extends Credentials

final case class AccessToken(
    token: String
) extends Credentials</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Sealed is very important!
Other examples: Either, Option, Enumeratum.</p></div></aside></section><section id="union_types"><h2>Union types</h2><div class="stemblock"><div class="content">\[X = Y|Z \iff (x : X \implies x : Y \lor x : Z)\]</div></div>
<aside class="notes"><div class="paragraph"><p>In dotty. Left == Right will result in one type.</p></div></aside></section><section id="union_types_2"><h2>Union types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">type My = String | Int</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Either[Int, Int] and Int | Int as an example of difference.</p></div></aside></section><section id="compound_types"><h2>Compound types</h2><div class="paragraph"><p>In set theory we have set intersection.</p></div>
<div class="paragraph"><p>What do we have in Scala type system?</p></div></section><section id="compound_types_2"><h2>Compound types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait Str { def str: String }
trait Count { def count: Int }

def repeat(cd: Str with Count): String =
  Iterator.fill(cd.count)(cd.str).mkString

repeat(new Str with Count {
  val str = "test"
  val count = 3
})</code></pre></div></div></section><section id="compound_types_3"><h2>Compound types</h2><div class="stemblock"><div class="content">\[x \in A \cap B \\
\Updownarrow \\
x \in A \land x \in B
\iff
x \in B \land x \in A \\
\Updownarrow \\
x \in B \cap A\]</div></div></section><section id="compound_types_4"><h2>Compound types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val sc: Str with Count
val ca: Count with Str
def repeat(sc) // works as expected
def repeat(ca) // also works!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>This is true only about signature.
Not about the behavior!</p></div></aside></section><section id="compound_types_5"><h2>Compound types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait A { def value = 10 }
trait B extends A { override def value = super.value * 2 }
trait C extends A { override def value = super.value + 2 }
(new B with C {}).value // ???
(new C with B {}).value // ???</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Diamond problem. Trait linearization.</p></div></aside></section><section id="compound_types_6"><h2>Compound types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait X extends A with B with C</code></pre></div></div>
<div class="paragraph"><p>is the same as</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait AnonymousB extends A {
  // B overrides A
  override def value = super.value * 2
}
trait AnonymousC extends AnonymousB {
  // C overrides AnonymousB
  override def value = super.value + 2
}
trait X extends AnonymousC</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>It helps if you put everything after extends in a parenthesis.</p></div></aside></section><section id="intersection_types"><h2>Intersection types</h2><div class="stemblock"><div class="content">\[X = Y&amp;Z \iff (x : X \implies x : Y \land x : Z)\]</div></div>
<aside class="notes"><div class="paragraph"><p>In dotty. Left == Right will result in one type.</p></div></aside></section><section id="intersection_types_2"><h2>Intersection types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">type My = String &amp; Int</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>It should be commutative (in behavior)
as opposed to compound types.</p></div></aside></section></section>
<section id="classes"><h2>Classes</h2><div class="paragraph"><p>Mathematically:</p></div>
<div class="quoteblock"><blockquote><div class="paragraph"><p>A <strong>class</strong> is such group of objects for which some predicate
(an <strong>indicator function</strong>) returns true.</p></div></blockquote></div>
<div class="paragraph"><p>Programming:</p></div>
<div class="quoteblock"><blockquote><div class="paragraph"><p>A recipe for <strong>objects</strong> + contracts. <strong>Instances</strong> of that class can be a type.</p></div></blockquote></div>
<aside class="notes"><div class="paragraph"><p>Examples of contracts: has method, has field.</p></div>
<div class="paragraph"><p>In some OOP language all classes are types, but not all types are classes, e.g. primitives, void.</p></div>
<div class="paragraph"><p>In statically-typed languages that recipe dictates memory layout of the object.</p></div>
<div class="paragraph"><p>In dynamically-typed languages class is a factor object,
that creates other objects.</p></div>
<div class="paragraph"><p>In prototype-based languages it object might redirect calls
to a prototype. So we reason whether object or its prototype
follows some contracts. More or less.</p></div></aside></section>
<section id="unit"><h2>Unit</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">(): Unit</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Origin: it is convinient (in some theories obligatory) that
each funtion takes arguments and returns values.</p></div>
<div class="paragraph"><p>So 0-argument functions or functions returning no value is
a no-go. Cathegory theory uses void as an argument for nullary
and unit for procedures (fun without returned values).</p></div>
<div class="paragraph"><p>It is NOT a 0-tuple, which IMHO is a mistake.</p></div></aside></section>
<section><section id="type_constructors"><h2>Type Constructors</h2><div class="paragraph"><p><span class="fragment">If we have a concrete type - e.g. <code>String</code> - we know it is a set of values.</span></p></div><div class="paragraph"><p><span class="fragment">What about <code>List</code>?</span></p></div></section><section id="types_and_sets_reminder"><h2>Types and Sets - reminder</h2><div class="ulist"><ul><li class="fragment"><p><em>type</em> - e.g. <code>Int</code> - set of values - e.g. 1, 2, 0, -5, &#8230;&#8203;</p></li><li class="fragment"><p><em>function</em> - e.g. <code>Int &#8658; Int</code> - set of pairs <code>(Int, Int)</code>, where first value doesn&#8217;t repeat - e.g. <code>(1,1,), (2,4), (3,9), &#8230;&#8203;</code></p></li><li class="fragment"><p>we can make a pair of sets (types),</p></li><li class="fragment"><p>function can take set (type) as an argument and return set (type) as a value</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Mention that this is true mathematically, wise as PL aren&#8217;t usually that flexible.</p></div>
<div class="paragraph"><p>Mention that map is an example of such pair based function, though.</p></div></aside></section><section id="types_and_sets_reminder_2"><h2>Types and Sets - reminder</h2><div class="paragraph"><p>(TODO: add image of List function)</p></div></section><section id="types_and_sets_reminder_3"><h2>Types and Sets - reminder</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">// [A] declares type parameter A
class Wrapper[A](value: A)

val wrapped1 = new Wrapper[Int](1)
// Wrapper[Int] - Int passed explicitly

val wrapped2 = new Wrapper(2)
// Wrapper[Int] - Int inferred</code></pre></div></div>
<div class="paragraph"><p>Examples: <code>Option[A]</code>, <code>List[A]</code>, <code>Either[L, R]</code>.</p></div>
<aside class="notes"><div class="paragraph"><p>Mention, that more details about how parametric types works
is in the second part of the presentation.</p></div></aside></section></section>
<section id="summary"><h2>Summary</h2><div class="ulist"><ul><li class="fragment"><p>a type is a set of values</p></li><li class="fragment"><p>a subset, a product set, a set sum and intersection translates to a subtype, a product type, a sum type and an compound/intersection types</p></li><li class="fragment"><p>a class is a type</p></li><li class="fragment"><p>unit exist to avoid special cases</p></li><li class="fragment"><p>on mathematical level a parametric type is a function from type to type</p></li></ul></div></section>
<section id="code_all_you_need_to_know_about_types_in_scala_code"><h2><code>All you need to know about types in Scala</code></h2></section>
<section id="what_is_a_kind"><h2>What is a kind?</h2><div class="paragraph"><p>A type of a type :)</p></div>
<aside class="notes"><div class="paragraph"><p>Here run snippets in</p></div>
<div class="paragraph"><p>pushd /tmp &amp;&amp; sbt console || popd</p></div>
<div class="paragraph"><p>:kind String</p></div>
<div class="paragraph"><p>:kind List</p></div>
<div class="paragraph"><p>:kind Either</p></div>
<div class="paragraph"><p>import scala.language.higherKinds</p></div>
<div class="paragraph"><p>trait NeedTC[F[_]]</p></div>
<div class="paragraph"><p>:kind NeedTC</p></div></aside></section>
<section><section id="type_constraints"><h2>Type constraints</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">sealed trait User { val id: Int }
case class Member(id: Int, name: String) extends User
case class Admin(id: Int, accss: Set[String]) extends User</code></pre></div></div><div class="paragraph"><p>Map[id, user] - approach 1</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def byId(users: Set[User]): Map[Int, User] =
  users.map { u =&gt; u.id -&gt; u }.toMap</code></pre></div></div><div class="paragraph"><p>Map[id, user] - approach 2</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def byId[U](users: Set[U])(getId: U =&gt; Int): Map[Int, U] =
  users.map { u =&gt; getId(u) -&gt; u }.toMap</code></pre></div></div></section><section id="upper_bound"><h2>Upper Bound</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">sealed trait User { val id: Int }
case class Member(id: Int, name: String) extends User
case class Admin(id: Int, accss: Set[String]) extends User</code></pre></div></div>
<div class="paragraph"><p>Map[id, user] - approach 1</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def byId[U &lt;: User](users: Set[U]): Map[Int, U] =
  users.map { u =&gt; u.id -&gt; u }.toMap</code></pre></div></div>
<div class="paragraph"><p>Map[id, user] - approach 2</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">byId(users: Set[Member]) // Map[Int, Member]
byId(users: Set[Admin]) // Map[Int, Admin]</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>&lt;: denotes an upper bound in type parameters. It look like this, so that parser would not confuse it with &lt;, but its meaning is similar - a type on the left is smaller (lies lower in hierarchy) than a type on the right</p></div></aside></section><section id="lower_bound"><h2>Lower Bound</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def recover[E, A, B &gt;: A](
    either: Either[E, A])(f: E =&gt; B): Either[E, B] =
  either match {
    case Left(e)  =&gt; Right(f(e))
    case Right(a) =&gt; Right(a)
  }</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">recover[String, Admin, User](err: Either[String, Admin]) {
    _ =&gt;
  fallback: Member
}
// Either[String, User]</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>I need to pass types explicitly, otherwise type inference would put Nothing there.</p></div></aside></section><section id="generalized_type_constraints"><h2>Generalized type constraints</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def upcast[A, B](set: Set[A])(
  implicit ev: A &lt;:&lt; B // A is a subclass of B
): Set[B] = set.map(ev(_))

upcast[Member, User](Set(m: Member)) // Set[User]</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def update[A, B](set: Set[A])(f: A =&gt; B)(
  implicit ev: A =:= B // types are equal
): Set[B] = set.map(f)

val members: Set[Member]

update[Member, Member](members)(identity) // ok
update[Member, User](members) { member =&gt;
  member: User
} // compilation error!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>&lt;:&lt; is defined in scala.Predef</p></div></aside></section><section id="generalized_type_constraints_2"><h2>Generalized type constraints</h2><div class="ulist"><ul><li><p><code>&lt;%&lt;</code> - already removed from Scala, meant A is a suptype is is implicitly convertible to B,</p></li><li><p><code>=:!=</code> - types differ - provided by Shapeless</p></li></ul></div></section><section id="type_class_syntax"><h2>Type class syntax</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait X[F[_]]

def needX[F[_] : X] = ??? // is equal to
def needX[F[_]](implicit xf: X[F]) = ???</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>This way we can treat <em>has type class</em> in scope as a type constraint.</p></div></aside></section></section>
<section><section id="variance"><h2>Variance</h2></section><section id="mutability_and_subtyping"><h2>Mutability and Subtyping</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="java language-java">String[] strings = new String[3];
strings[0] = "1";
strings[1] = "2"; // ok so far

Object[] objects = strings; // we can do that as well
objects[2] = (Integer) 3;
// java.lang.ArrayStoreException: java.lang.Integer</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="java language-java">List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add(0, "1");
strings.add(1, "2");

List&lt;Object&gt; objects = strings; // compilation error</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>What we expected and what went wrong?</p></div></aside></section><section id="invariance"><h2>Invariance</h2><div class="paragraph"><p>Situation where:</p></div>
<div class="stemblock"><div class="content">\[A &lt;: B \\
\neg F[A] &lt;: F[B] \land \neg F[B] &lt;: F[A]\]</div></div>
<div class="paragraph"><p>is called <em>invariance</em>.</p></div>
<aside class="notes"><div class="paragraph"><p>In Scala it is default.</p></div></aside></section><section id="immutable_containers"><h2>Immutable containers</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">sealed trait Option[T] {}
case class Some[T](value: T) extends Option[T]
case class None[T]() extends Option[T]</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class A
class B extends A

val o: Option[B] = Some(new B)

def withOptA(opt: Option[A]) = ???

withOptA(o) // doesn't work

None[A]() != None[B]() // doesn't make sense</code></pre></div></div></section><section id="covariance"><h2>Covariance</h2><div class="paragraph"><p>Situation where:</p></div>
<div class="stemblock"><div class="content">\[A &lt;: B \implies F[A] &lt;: F[B]\]</div></div>
<div class="paragraph"><p>is called <em>covariance</em>.</p></div>
<aside class="notes"><div class="paragraph"><p>In Scala denoted by + sign in front of type parameter.</p></div></aside></section><section id="covariance_2"><h2>Covariance</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">sealed trait Option[+T] {} // + makes the difference
case class Some[+T](value: T) extends Option[T]
object None extends Option[Nothing]</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class A
class B extends A

val o: Option[B] = Some(new B)

def withOptA(opt: Option[A]) = ???

withOptA(o) // compiles

(None: Option[A]) == (None: Option[B]) // true</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Used in containers or any sort of publishers that emit/return a value.</p></div>
<div class="paragraph"><p>Function interface is covariant when it comes to returned value.</p></div></aside></section><section id="subscribers"><h2>Subscribers</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait Subscriber[A] {

  def apply(value: A): Unit
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class A
class B extends A

val subscriberA: Subscriber[A]

List(new B).foreach(subscriberA) // compilation fails!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Invariance fails.</p></div>
<div class="paragraph"><p>Covariance doesn&#8217;t help because we don&#8217;t want to make
List[B] a List[A], but let Subscriber[A] be used as Subscriber[B].</p></div>
<div class="paragraph"><p>We don&#8217;t want to make B more generic, but A more specific.</p></div></aside></section><section id="contravariance"><h2>Contravariance</h2><div class="paragraph"><p>Situation where:</p></div>
<div class="stemblock"><div class="content">\[A &lt;: B \implies F[B] &lt;: F[A]\]</div></div>
<div class="paragraph"><p>is called <em>contravariance</em>.</p></div>
<aside class="notes"><div class="paragraph"><p>In Scala denoted by - sign in front of type parameter.</p></div></aside></section><section id="contravariance_2"><h2>Contravariance</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait Subscriber[-A] { // - makes the difference

  def apply(value: A): Unit
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class A
class B extends A

val subscriberA: Subscriber[A]

List(new B).foreach(subscriberA) // works!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Function interface is contravariant when it comes to the argument.</p></div></aside></section><section id="variances"><h2>Variances</h2><div class="paragraph"><p>Variances - invariance, covariance, contravariance - is related to type parameter, not the whole type.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait Function1[-A, +B] {

  def apply(arg: A): B
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val function: Function1[A, B]

def b2b(f: Function[B, B]): Unit
def a2a(f: Function[A, A]): Unit

b2b(function) // accepting more generic argument is ok
a2a(function) // returning more specific result is ok</code></pre></div></div></section></section>
<section><section id="existential_types"><h2>Existential types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def count[T](seqs: Seq[T]*): Int = seqs.map(_.size).sum</code></pre></div></div><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">count(Seq(1,2,3), Seq("test")) // 4</code></pre></div></div><aside class="notes"><div class="paragraph"><p>We never make use of T. We don&#8217;t care about it at all!</p></div></aside></section><section id="existential_types_2"><h2>Existential types</h2><div class="paragraph"><p><strong>Universal type</strong></p></div>
<div class="stemblock"><div class="content">\[\forall_T count: Seq_{Seq_T} \rightarrow int\]</div></div>
<div class="paragraph"><p><strong>Existential type</strong></p></div>
<div class="stemblock"><div class="content">\[seq: Seq_? \iff \exists_{T} seq: Seq_T \\
count: Seq_{Seq_?} \rightarrow int\]</div></div></section><section id="existential_types_3"><h2>Existential types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def count(seqs: Seq[_]*): Int // syntactic sugar for
def count(seqs: (Seq[T] forSome { type T })*): Int</code></pre></div></div>
<div class="paragraph"><p>Java also has them!</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="java language-java">int count(java.util.List&lt;?&gt;... seqs) {
    return Arrays.stream(seqs)
        .mapToInt(seq -&gt; seq.size())
        .sum();
}</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Explain, that existential types are not the same thing as typ constructors!</p></div>
<div class="paragraph"><p>They just happen to share the same syntax.</p></div>
<div class="paragraph"><p>Type constructors are about types that are not yet fully constructed and appear as type params.
Existential types are about fogetting type parameter of existing value and appear in type ascription.</p></div></aside></section></section>
<section><section id="structural_types"><h2>Structural types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="javascript language-javascript">type User = { name: string, surname: string }</code></pre></div></div></section><section id="structural_types_2"><h2>Structural types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="javascript language-javascript">type User = {
  val name: String
  val surname: String
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">case class Somebody(name: String, surname: String)

def needUser(user: User): Unit

needUser(Somebody("test", "test")) // works!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Explain that accessing value of a structural type requires runtime reflection, so it is a performance penalty.</p></div></aside></section><section id="refined_types"><h2>Refined types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait X { val x: String }
type Y = { val y: Int }
val z: X with Y = new X { val x = "test"; val y = 0 }</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">new X { val x = "test"; val y = 0 }
// AnyRef with X{val y: Int}</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>Refined type is the same thing as structural type, just in a specific context.</p></div>
<div class="paragraph"><p>Mention that Java 10 with var has them but in half baked way
(no way fot you to describe the type).</p></div></aside></section></section>
<section><section id="path_dependent_types"><h2>Path-dependent types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">case class Card(color: String, value: String)
case class Player(name: String)
class Game {
  def getPlayers: Set[Players] = ???
  def getCards: Set[Cards] = ???
  def playerPlayCard(player: Player, card: Card): Unit = ???
}</code></pre></div></div><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val game1: Game
val game2: Game
game1.playerPlayCard(game2.getPlayers.head,
                     game2.getCards.head) // oops!</code></pre></div></div></section><section id="path_dependent_types_2"><h2>Path-dependent types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class Game {
  case class Card(color: String, value: String)
  case class Player(name: String)

  def getPlayers: Set[this.Player] = ???
  def getCards: Set[this.Card] = ???
  def playerPlayCard(player: this.Player,
                     card: this.Card): Unit = ???
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">val game1 = new Game
val game2 = new Game
game1.getPlayers // Set[game1.Player]
game2.getPlayers // Set[game2.Player]</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">game1.playerPlayCard(game2.getPlayers.head,
                     game2.getCards.head) // fails!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>In Java that would translate to internal class, but here
we are also able to trace from which object it originated.</p></div>
<div class="paragraph"><p>Path-dependent types are used in e.g. Slick or in compiler macros.</p></div></aside></section><section id="path_dependent_types_3"><h2>Path-dependent types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">class X {
  type Y = String
  val y: Y = "y"
}

val x1 = new X
val x2 = new X</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def y(x: X)(y: x.Y): Unit = ()

y(x1)(x2.y) // no complaints: x1.Y = String = x2.Y</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>If Scala can figure out the exact type, then path-dependant types might dissapear.</p></div></aside></section><section id="path_dependent_types_4"><h2>Path-dependent types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait X {
  type Y = String
  val y: Y = "y"
}

class X2 extends X

val x1 = new X2
val x2 = new X2

y(x1)(x2.y) // fails!</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>We can always make type Y abstract, which is why Scala cannot assume
things will be as they are. (More or less).</p></div></aside></section><section id="path_dependent_types_5"><h2>Path-dependent types</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">trait X {
  type Y
  val y: Y
}

val x1 = new X {
  type Y = String
  val y: Y = "y"
}
val x2 = new X {
  type Y = Int
  val y: Y = 1
}</code></pre></div></div></section><section id="getting_rid_of_path_dependency"><h2>Getting rid of path-dependency</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def takeAnyPlayer(p: Game#Player): Unit</code></pre></div></div></section></section>
<section><section id="kind_projectors"><h2>Kind projectors</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">type MonadThrowable[F[_]] = MonadError[F, Throwable]
def handleError[F[_]: MonadThrowable, A](fa: F[A]): F[A</code></pre></div></div><aside class="notes"><div class="paragraph"><p>To get rid of intermediate type:</p></div>
<div class="ulist"><ul><li><p>put it into structural type</p></li><li><p>use path-dependent type to extract type with applied one parameter</p></li></ul></div></aside></section><section id="kind_projectors_2"><h2>Kind projectors</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">type MT { type T[F[_]] = MonadError[F, Throwable] }
def handleError[F[_]: MT#T, A](fa: F[A]): F[A]</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>To get rid of intermediate type:</p></div>
<div class="ulist"><ul><li><p>replace type alias with its definition</p></li></ul></div></aside></section><section id="kind_projectors_3"><h2>Kind projectors</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def handleError[
  F[_] : ({ type T[F[_]] = MonadError[F, Throwable] })#T,
  A
](fa: F[A]): F[A]</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>You have to use parethesis or it will break.</p></div>
<div class="paragraph"><p>Mention that lambda sign is often used to denote the kind projector.</p></div>
<div class="paragraph"><p>Mention it is also known as type-lambda.</p></div>
<div class="paragraph"><p>Mention, that usually kind projector compiler plugin is used.</p></div></aside></section><section id="kind_projectors_4"><h2>Kind projectors</h2><div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">def handleError[F[_] : MonadError[?, Throwable], A](
  fa: F[A]
): F[A]</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code data-noescape class="scala language-scala">[T] =&gt; Either[String, T]</code></pre></div></div>
<aside class="notes"><div class="paragraph"><p>First - kind projecttor plugin.</p></div>
<div class="paragraph"><p>Second - Dotty.</p></div></aside></section></section>
<section id="summary_2"><h2>Summary</h2><div class="ulist"><ul><li class="fragment"><p>we have a quite fine grained control over type parameters and their usage</p></li><li class="fragment"><p>Scala does it best to preserve the type information even if we don&#8217;t need it (now)</p></li><li class="fragment"><p>you (and surely some library authors) will use path-dependent types
to ensure that some values will be passed only in the right context</p></li></ul></div></section>
<section id="more_info"><h2>More info</h2><div class="ulist"><ul><li><p>my blog post (add link)</p></li><li><p>ktoso (add link)</p></li><li><p>official documentation (add link)</p></li></ul></div></section>
<section id="questions"><h2>Questions?</h2></section>
<section id="thanks"><h2>Thanks!</h2></section></div></div><script src="./lib/js/head.min.js"></script><script src="./js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Set a per-slide timing for speaker notes, null means none
  defaultTiming: null,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: './plugin/zoom-js/zoom.js', async: true },
      { src: './plugin/notes/notes.js', async: true }
  ]
});</script></body></html>