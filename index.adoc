= From Types to Kind Projectors

[NOTE.speaker]
--
Mention that whole presentaiton consitsts of 2 parts.

part 1 - for newbies

part 2 - for people who already know something
--


// part 1

== `Introduction to Types`


== What is a Type?

[NOTE.speaker]
--
Ask audience before moving on.
--


=== Intuitively

[fragment]#A collection of values#

[fragment]#(TODO add image of some int and string sets)#

[NOTE.speaker]
--
Type is kinda like set except sets are in different thery.
--


=== Example

[source, scala]
--
// type annotation

val i: Int    = 0   // value i = 0 is of type Int
val s: String = "a" // value s = "a" is of type String

def double(x: Int): Int = x * 2

// type ascription


0 : Int // compiles because it is true
"": Int // fails to compile
--

[NOTE.speaker]
--
TT: `a: A` is judgement - it means that a is of type A

Type annotation - stating type explicitly.

Type ascription - demanding of compiler to make sure value
can be judged as some type.
--


=== Subtype & Supertype

(TODO image with member and admin as subtypes of user)


=== Subtype & Supertype

[stem]
++++
(Member <: User) \\
\Updownarrow \\
\forall_a (a : Member \implies a : User)
++++


=== Subtype & Supertype

[source, scala]
----
trait User
class Member extends User
class Admin extends User
----

=== Subtype & Supertype

(image with admin as a subtype of user)


=== Subtype & Supertype

[source, scala]
----
class User
class Admin extends User
----

== Least Upper Bound and Type Inference


=== Some Type Hierarchy

(TODO image of type hierarchy from post)


=== Example

[source, scala]
----
val i: Int
val x = if (i >= 0) Some(i) // Some[Int]
        else None           // None
// what is the type of x?
----


=== Types of `Some(i)`

(TODO add image)


=== Types of `None`

(TODO add image)


=== Common part

(TODO add image)


=== Least Upper Bound

> *Least Upper Bound* of a - the least type T for which judgement
a : T is provable to be true

> *Type Inference* - finding the LUB of a value



=== Example

[source, scala]
----
val i: Int
val x = if (i >= 0) Some(i) // Some[Int]
        else None           // None
// x: Option[Int]
----


== ADT


[fragment]#ADT is either a *product* or **coproduct** type. :)#

[fragment]#But what are product and coproduct types?#

[NOTE.speaker]
--
Explain that now we will talk about:
tuples -> cartesian products -> sum types
--

=== Tuple

> A *tuple* or an **ordered pair**, is a collection of two elements,
where we select one of them as the first.

In set theory we can define them as:

[stem]
++++
(a, b) = \{\{a\}, \{a,b\}\}
++++


=== Cartesian Product of 2

[stem]
++++
A \times B = \{ (a, b): a \in A \land b \in B \}
++++


=== n-tuple

[stem]
++++
(a, b, c) = (a, (b, c)) \\
(a, b, c, d) = (a, (b, (c, d))) \\
...
++++

[NOTE.speaker]
--
In programming languages we make n-tuples right associative.

In mathematics they are left associative.
--


=== Cartesian Product of n

Generalization of Cartesian product:

[stem]
++++
A \times B \times C = \{ (a, b, c): a \in A \land b \in B \land c \in C \} \\
A \times B \times C = A \times (B \times C) \\
A \times B \times C \times D = A \times (B \times (C \times D)) \\
...
++++


=== Product types

[source, scala]
----
type X = (String, Int, Double)
type Y = Tuple3[String, Int, Double]
case class Z(s: String, i: Int, d: Double)
class Z2(val s: String, val i: Int, val d: Double)

import shapeless._
String :: Int :: Double :: HNil
----

[NOTE.speaker]
--
Mention shapeless `HList` and the concept of cons.
--


=== Disjoint union

[stem]
++++
X = Y|Z \iff (x : X \implies x : Y \veebar x : Z)
++++

[NOTE.speaker]
--
Mention concept of tags. And that this is XOR!
--


=== Disjoint union

[source, scala]
----
sealed trait Credentials

final case class LoginPassword(
    login: String,
    password: String
) extends Credentials

final case class AccessToken(
    token: String
) extends Credentials
----

[NOTE.speaker]
--
Sealed is very important!
Other examples: Either, Option, Enumeratum.
--


=== Union types

[stem]
++++
X = Y|Z \iff (x : X \implies x : Y \lor x : Z)
++++

[NOTE.speaker]
--
In dotty. Left == Right will result in one type.
--


=== Union types

[source, scala]
----
type My = String | Int
----

[NOTE.speaker]
--
Either[Int, Int] and Int | Int as an example of difference.
--


=== Compound types

[%step]
In set theory we have set intersection.

[%step]
What do we have in Scala type system?


=== Compound types

[source, scala]
----
trait Str { def str: String }
trait Count { def count: Int }

def repeat(cd: Str with Count): String =
  Iterator.fill(cd.count)(cd.str).mkString

repeat(new Str with Count {
  val str = "test"
  val count = 3
})
----


=== Compound types

[stem]
++++
x \in A \cap B \\
\Updownarrow \\
x \in A \land x \in B
\iff
x \in B \land x \in A \\
\Updownarrow \\
x \in B \cap A
++++


=== Compound types

[source, scala]
----
val sc: Str with Count
val ca: Count with Str
def repeat(sc) // works as expected
def repeat(ca) // also works!
----

[NOTE.speaker]
--
This is true only about signature.
Not about the behavior!
--


=== Compound types

[source, scala]
----
trait A { def value = 10 }
trait B extends A { override def value = super.value * 2 }
trait C extends A { override def value = super.value + 2 }
(new B with C {}).value // ???
(new C with B {}).value // ???
----

[NOTE.speaker]
--
Diamond problem. Trait linearization.
--


=== Compound types

[source, scala]
----
trait X extends A with B with C
----

is the same as

[source, scala]
----
trait AnonymousB extends A {
  // B overrides A
  override def value = super.value * 2
}
trait AnonymousC extends AnonymousB {
  // C overrides AnonymousB
  override def value = super.value + 2
}
trait X extends AnonymousC
----

[NOTE.speaker]
--
It helps if you put everything after extends in a parenthesis.
--


=== Intersection types

[stem]
++++
X = Y&Z \iff (x : X \implies x : Y \land x : Z)
++++

[NOTE.speaker]
--
In dotty. Left == Right will result in one type.
--


=== Intersection types

[source, scala]
----
type My = String & Int
----

[NOTE.speaker]
--
It should be commutative (in behavior)
as opposed to compound types.
--


== Classes

Mathematically:

> A *class* is such group of objects for which some predicate
(an **indicator function**) returns true.

Programming:

> A recipe for *objects* + contracts. *Instances* of that class can be a type.

[NOTE.speaker]
--
Examples of contracts: has method, has field.

In some OOP language all classes are types, but not all types are classes, e.g. primitives, void.

In statically-typed languages that recipe dictates memory layout of the object.

In dynamically-typed languages class is a factor object,
that creates other objects.

In prototype-based languages it object might redirect calls
to a prototype. So we reason whether object or its prototype
follows some contracts. More or less.
--


== Unit

[source, scala]
----
(): Unit
----

[NOTE.speaker]
--
Origin: it is convinient (in some theories obligatory) that
each funtion takes arguments and returns values.

So 0-argument functions or functions returning no value is
a no-go. Cathegory theory uses void as an argument for nullary
and unit for procedures (fun without returned values).

It is NOT a 0-tuple, which IMHO is a mistake.
--


== Type Constructors

TODO


== Summary

TODO


// part 2

== `All you need to know about types in Scala`

TODO


== What is a kind?

A type of type :)

[NOTE.speaker]
--
Here run snippets in

pushd /tmp && sbt console || popd

:kind String

:kind List

:kind Either

import scala.language.higherKinds

trait NeedTC[F[_]]

:kind NeedTC
--


== Type constraints

TODO


== Variance

TODO


== Existential types

TODO


== Structural types

TODO

also reinfed


== Path-dependent types

TODO


== Kind-projectors

TODO


== Summary

TODO

